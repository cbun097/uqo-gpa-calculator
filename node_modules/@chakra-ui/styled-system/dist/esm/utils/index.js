import { get, getWithDefault, isNumber } from "@chakra-ui/utils";
import { positiveOrNegative } from "./positive-or-negative";
export * from "./positive-or-negative";
export * from "./sort";
export * from "./types";
export function makeConfig(scale, transform) {
  return prop => {
    var result = {
      scale
    };
    if (transform) result.transform = transform;
    if (Array.isArray(prop)) result.properties = prop;else result.property = prop;
    return result;
  };
}

function fractionalValue(value, scale) {
  var defaultValue = !isNumber(value) || value > 1 ? value : value * 100 + "%";
  return get(scale, value, defaultValue);
}

export var t = {
  borderWidths: makeConfig("borderWidths"),
  borderStyles: makeConfig("borderStyles"),
  colors: makeConfig("colors"),
  borders: makeConfig("borders"),
  radii: makeConfig("radii"),
  space: makeConfig("space"),
  spaceT: makeConfig("space", positiveOrNegative),
  prop: (property, transform) => ({
    property,
    transform
  }),
  sizes: makeConfig("sizes"),
  sizesT: makeConfig("sizes", fractionalValue),
  shadows: makeConfig("shadows")
};
export function getIsRtl(props) {
  var theme = "theme" in props ? props.theme : props;
  return theme.direction === "rtl";
}
/**
 * Polyfill for border-{start|end}-radius properties.
 * We'll remove this once css logical properties is supported in major browsers
 */

export function polyfill(map) {
  return (value, scale, props) => {
    var isRtl = getIsRtl(props);
    var raw = getWithDefault(value, scale);
    var result = {};

    if (Array.isArray(map.ltr)) {
      map.ltr.forEach((_, i) => {
        result[isRtl ? map.rtl[i] : map.ltr[i]] = raw;
      });
    } else {
      result[isRtl ? map.rtl : map.ltr] = raw;
    }

    return result;
  };
}
/**
 * Credits to https://github.com/kentcdodds/rtl-css-js/blob/aaf3e9885026de11b01f3b73258f25e21b7432f7/src/internal/utils.js
 * @todo use this for margin, padding, border-radius value transformations in rtl
 */

function getValuesAsList(value) {
  return value.replace(/ +/g, " ").split(" ").map(i => i.trim()).filter(Boolean).reduce((_ref, item) => {
    var {
      list,
      state
    } = _ref;
    var openParansCount = (item.match(/\(/g) || []).length;
    var closedParansCount = (item.match(/\)/g) || []).length;

    if (state.parensDepth > 0) {
      list[list.length - 1] = list[list.length - 1] + " " + item;
    } else {
      list.push(item);
    }

    state.parensDepth += openParansCount - closedParansCount;
    return {
      list,
      state
    };
  }, {
    list: [],
    state: {
      parensDepth: 0
    }
  }).list;
}

export function handleQuartetValues(value) {
  var splitValues = getValuesAsList(value);

  if (splitValues.length <= 3 || splitValues.length > 4) {
    return value;
  }

  var [top, right, bottom, left] = splitValues;
  return [top, left, bottom, right].join(" ");
}
export var isRtl = theme => theme.direction === "rtl";
//# sourceMappingURL=index.js.map